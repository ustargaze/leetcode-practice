# 第 124 场双周赛 (2024-02-17)

> https://leetcode.cn/contest/biweekly-contest-124/

## [相同分数的最大操作数目 I](https://leetcode.cn/problems/maximum-number-of-operations-with-the-same-score-i/)
**思路**

直接模拟


**代码**

```java
class Solution {
    public int maxOperations(int[] nums) {
        int n = nums.length;
        int score = nums[0] + nums[1];
        int ans = 1;

        for (int i = 2; i < n - 1; i += 2) {
            if (nums[i] + nums[i + 1] == score) {
                ans++;
            } else {
                break;
            }
        }

        return ans;
    }
}
```

**复杂度分析**

- 时间复杂度：$O(n)$。
- 空间复杂度：$O(1)$。


--------------------

## [进行操作使字符串为空](https://leetcode.cn/problems/apply-operations-to-make-string-empty/)
**思路**

找到字符串中出现次数最多的字符，将所有出现次数最多的字符按照最后一次出现的位置的顺序拼接成字符串即为结果。


**代码**

```java
class Solution {
    public String lastNonEmptyString(String s) {
        int n = s.length();
        char[] chars = s.toCharArray();

        List<Integer>[] positions = new List[26];
        for (int i = 0; i < n; i++) {
            int idx = chars[i] - 'a';
            if (positions[idx] == null) {
                positions[idx] = new ArrayList<>();
            }
            positions[idx].add(i);
        }

        int maxLength = 0;
        for (List<Integer> position : positions) {
            maxLength = Math.max(maxLength, position == null ? 0 : position.size());
        }

        List<int[]> remainChars = new ArrayList<>();
        for (int i = 0; i < 26; i++) {
            if (positions[i] != null && positions[i].size() == maxLength) {
                remainChars.add(new int[]{positions[i].getLast(), i});
            }
        }
        remainChars.sort(Comparator.comparingInt(a -> a[0]));

        StringBuilder ans = new StringBuilder();
        for (int[] remainChar : remainChars) {
            ans.append((char) (remainChar[1] + 'a'));
        }
        
        return ans.toString();
    }
}
```

**复杂度分析**

- 时间复杂度：$O(n+Ʃ \log Ʃ)$。Ʃ 为字符集大小，n 为字符串长度。
- 空间复杂度：$O(n)$。


--------------------

## [相同分数的最大操作数目 II](https://leetcode.cn/problems/maximum-number-of-operations-with-the-same-score-ii/)
**思路**

记忆化搜索。


**代码**

```java
class Solution {
    public int maxOperations(int[] nums) {
        int n = nums.length;
        Map<Integer, Integer>[][] memory = new Map[n][n];
        return Math.max(dfs(0, n - 3, nums, nums[n - 1] + nums[n - 2], memory) + 1, Math.max(dfs(1, n - 2, nums, nums[0] + nums[n - 1], memory) + 1, dfs(2, n - 1, nums, nums[0] + nums[1], memory) + 1));
    }

    private int dfs(int i, int j, int[] nums, int score, Map<Integer, Integer>[][] memory) {
        if (i >= j) {
            return 0;
        }

        if (memory[i][j] != null && memory[i][j].containsKey(score)) {
            return memory[i][j].get(score);
        }

        int res = 0;
        if (nums[i] + nums[i + 1] == score) {
            res = Math.max(res, dfs(i + 2, j, nums, score, memory) + 1);
        }
        if (nums[i] + nums[j] == score) {
            res = Math.max(res, dfs(i + 1, j - 1, nums, score, memory) + 1);
        }
        if (nums[j - 1] + nums[j] == score) {
            res = Math.max(res, dfs(i, j - 2, nums, score, memory) + 1);
        }

        if (memory[i][j] == null) {
            memory[i][j] = new HashMap<>();
        }

        memory[i][j].put(score, res);

        return res;
    }
}
```

**复杂度分析**

- 时间复杂度：$O(n^2)$。
- 空间复杂度：$O(n^2)$。


--------------------

## [修改数组后最大化数组中的连续元素数目](https://leetcode.cn/problems/maximize-consecutive-elements-in-an-array-after-modification/)
**思路**

先将 nums 排序。

用 dp\[i]\[0] 表示排序之后的第 i 个元素不加 1 时，前 i 个元素能够获得的连续子序列的最大长度；

用 dp\[i]\[1] 表示排序之后的第 i 个元素加 1 时，前 i 个元素能够获得的连续子序列的最大长度。

初始 dp\[0]\[0] dp\[0]\[1] 均为 1。

有

1. 第 i - 1 的元素不加 1，第 i 的元素不加 1；
2. 第 i - 1 的元素加 1，第 i 的元素不加 1；
3. 第 i - 1 的元素不加 1，第 i 的元素加 1；
4. 第 i - 1 的元素加 1，第 i 的元素加 1；

四种情况，如果执行操作之后 nums[i - 1] + 1 == nums[i]，则 dp[i] = dp[i-1] + 1，如果执行操作之后 nums[i - 1]  == nums[i]，则 dp[i] = dp[i-1]，否则 dp[i] = 0。（这里的 dp[i] 省去了后面的 [0] / [1]，是 0 还是 1 与操作对应）

**代码**

```java
class Solution {
    public int maxSelectedElements(int[] nums) {
        int n = nums.length;
        Arrays.sort(nums);
        int[][] dp = new int[n][2];
        dp[0][0] = 1;
        dp[0][1] = 1;

        int ans = 1;
        for (int i = 1; i < n; i++) {
            dp[i][0] = 1;
            dp[i][1] = 1;

            if (nums[i - 1] + 1 == nums[i]) {
                dp[i][0] = Math.max(dp[i][0], dp[i - 1][0] + 1);
                dp[i][1] = Math.max(dp[i][1], dp[i - 1][1] + 1);
            }
            if (nums[i - 1] + 2 == nums[i]) {
                dp[i][0] = Math.max(dp[i][0], dp[i - 1][1] + 1);
            }
            if (nums[i - 1] == nums[i]) {
                dp[i][0] = Math.max(dp[i][0], dp[i - 1][0]);
                dp[i][1] = Math.max(dp[i][1], Math.max(dp[i - 1][0] + 1, dp[i - 1][1]));
            }

            ans = Math.max(ans, Math.max(dp[i][0], dp[i][1]));
        }
        return ans;
    }
}
```

**复杂度分析**

- 时间复杂度：$O(n \log n)$。
- 空间复杂度：$O(n)$。

