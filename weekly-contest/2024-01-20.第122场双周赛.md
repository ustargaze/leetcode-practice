# 第 122 场双周赛 (2024-01-20)

> https://leetcode.cn/contest/biweekly-contest-122/

## [将数组分成最小总代价的子数组 I](https://leetcode.cn/problems/divide-an-array-into-subarrays-with-minimum-cost-i/)
**思路**

分成 3 个连续且没有交集的子数组，所以第一个值必定是代价的的一部分，要找到最小代价，只需要找到除第一个数之外的最小的两个数即可。

**代码**

```java
class Solution {
    public int minimumCost(int[] nums) {
        int a = Integer.MAX_VALUE - 1, b = Integer.MAX_VALUE;
        for (int i = 1; i < nums.length; i++) {
            if (nums[i] < a) {
                b = a;
                a = nums[i];
            } else if (nums[i] < b) {
                b = nums[i];
            }
        }
        return a + b + nums[0];
    }
}
```

**复杂度分析**

- 时间复杂度：$O(n)$。
- 空间复杂度：$O(1)$。


--------------------

## [判断一个数组是否可以变为有序](https://leetcode.cn/problems/find-if-array-can-be-sorted/)
**思路**

维护前一段的最大值和当前段的最大值和最小值，如果当前一段的最小值小于前一段的最大值则不可能有序。一段是指一段连续的数位相同的元素。


**代码**

```java
class Solution {
    public boolean canSortArray(int[] nums) {
        int n = nums.length;
        int lastMax = 0;
        int curCount = 0;
        int curMin = 101;
        int curMax = 0;
        for (int num : nums) {
            int count = countBit(num);
            if (count != curCount) {
                if (lastMax > curMin) {
                    return false;
                }
                lastMax = curMax;
                curCount = count;
                curMin = num;
                curMax = num;
            } else {
                curMin = Math.min(curMin, num);
                curMax = Math.max(curMax, num);
            }
        }
        return lastMax <= curMin;
    }

    private int countBit(int num) { // 可以直接用 Integer.bitCount()，对 java 使用还是没有那么熟悉
        int cnt = 0;
        while (num > 0) {
            cnt += num & 1;
            num >>= 1;
        }
        return cnt;
    }
}
```

**复杂度分析**

- 时间复杂度：$O(n)$。
- 空间复杂度：$O(1)$。


--------------------

## [通过操作使数组长度最小](https://leetcode.cn/problems/minimize-length-of-array-using-operations/)
**思路**

这道题非常有意思。

可以进行的操作是：任取两个非 0 数进行模运算将结果插入 nums 中，然后把取出的两个数删除。

这意味着每次取两个数 x，y 如果  x < y，进行 x % y 可以删除把 y 删掉。所以找到最小值，就可以把其他的数都删掉了。这个时候剩下的数进行模运算结果都是 0，最终会剩下 (minCount + 1) / 2 个。但是这可能不会最终结果，因为如果有一个数 x，x % min != 0，则结果必为 1。因为操作产生的新数如果不为 0，则必定小于 min，这样就出现了一个比之前还小的数，可以把所有的数都删掉。（最开始也没想到，有一个测试用例没通过发现的）


**代码**

```java
class Solution {
    public int minimumArrayLength(int[] nums) {
        int min = Integer.MAX_VALUE;
        for (int num : nums) {
            min = Math.min(min, num);
        }
        for (int num : nums) {
            if (num % min != 0) {
                return 1;
            }
        }
        int count = 0;
        for (int num : nums) {
            count += num == min ? 1 : 0;
        }
        return (count + 1) / 2;
    }
}
```

**复杂度分析**

- 时间复杂度：$O(n)$。
- 空间复杂度：$O(1)$。


--------------------

## [将数组分成最小总代价的子数组 II](https://leetcode.cn/problems/divide-an-array-into-subarrays-with-minimum-cost-ii/)
- <font color=red>**有点思路但是没做出来**</font>

