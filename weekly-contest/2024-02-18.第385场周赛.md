# 第 385 场周赛 (2024-02-18)

> https://leetcode.cn/contest/weekly-contest-385/

## [统计前后缀下标对 I](https://leetcode.cn/problems/count-prefix-and-suffix-pairs-i/)
**思路**

暴力破解


**代码**

```java
class Solution {
    public int countPrefixSuffixPairs(String[] words) {
        int n = words.length;
        int ans = 0;
        for (int i = 0; i < n - 1; i++) {
            for (int j = i + 1; j < n; j++) {
                if (words[j].startsWith(words[i]) && words[j].endsWith(words[i])) {
                    ans++;
                }
            }
        }
        return ans;
    }
}
```

**复杂度分析**

- 时间复杂度：$O(mn^2)$。m 为最长的字符串长度，n 为 words 数组的长度。
- 空间复杂度：$O(1)$。


--------------------

## [最长公共前缀的长度](https://leetcode.cn/problems/find-the-length-of-the-longest-common-prefix/)
**思路**

将 arr1 构造成字典树，然后遍历 arr2 中的元素通过字典树找到最长前缀。

**代码**

```java
class Solution {
    public int longestCommonPrefix(int[] arr1, int[] arr2) {
        Trie root = new Trie();
        for (int i : arr1) {
            root.insert(i);
        }
        
        int ans = 0;
        for (int i : arr2) {
            ans = Math.max(ans, root.searchPrefix(i));
        }
        
        return ans;
    }
}

class Trie {
    public Trie[] children = new Trie[10];
    public boolean end;
    
    public void insert(int num) {
        Deque<Integer> stack = new ArrayDeque<>(); 
        while (num > 0) {
            stack.push(num % 10);
            num /= 10;
        }
        
        Trie trie = this;
        while (!stack.isEmpty()) {
            int i = stack.pop();
            if (trie.children[i] == null) {
                trie.children[i] = new Trie();
            }
            trie = trie.children[i];
        }
        trie.end = true;
    }
    
    public int searchPrefix(int num) {
        Deque<Integer> stack = new ArrayDeque<>();
        while (num > 0) {
            stack.push(num % 10);
            num /= 10;
        }
        
        Trie trie = this;
        int prefix = 0;
        while (!stack.isEmpty()) {
            int i = stack.pop();
            if (trie.children[i] == null) {
                break;
            }
            trie = trie.children[i];
            prefix++;
        }
        return prefix;
    }
}
```

**复杂度分析**

- 时间复杂度：$O((m + n)\log_{10}{Ʃ})$。m 为 arr1 的长度，n 为 arr2 的长度。Ʃ 为 arr1 中的最大值。
- 空间复杂度：$O(Ʃ)$。粗略估计


--------------------

## [出现频率最高的素数](https://leetcode.cn/problems/most-frequent-prime/)
**思路**

直接模拟。


**代码**

```java
class Solution {
    public int mostFrequentPrime(int[][] mat) {
        int m = mat.length, n = mat[0].length;
        Map<Integer, Integer> map = new HashMap<>();

        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                // 向东移动
                int num = mat[i][j];
                int curI = i;
                int curJ = j + 1;
                while (curJ < n) {
                    num = num * 10 + mat[curI][curJ++];
                    if (isPrime(num)) {
                        map.put(num, map.getOrDefault(num, 0) + 1);
                    }
                }

                // 向东南移动
                num = mat[i][j];
                curI = i + 1;
                curJ = j + 1;
                while (curI < m && curJ < n) {
                    num = num * 10 + mat[curI++][curJ++];
                    if (isPrime(num)) {
                        map.put(num, map.getOrDefault(num, 0) + 1);
                    }
                }

                // 向南移动
                num = mat[i][j];
                curI = i + 1;
                curJ = j;
                while (curI < m) {
                    num = num * 10 + mat[curI++][curJ];
                    if (isPrime(num)) {
                        map.put(num, map.getOrDefault(num, 0) + 1);
                    }
                }

                // 向西南移动
                num = mat[i][j];
                curI = i + 1;
                curJ = j - 1;
                while (curI < m && curJ >= 0) {
                    num = num * 10 + mat[curI++][curJ--];
                    if (isPrime(num)) {
                        map.put(num, map.getOrDefault(num, 0) + 1);
                    }
                }

                // 向西移动
                num = mat[i][j];
                curI = i;
                curJ = j - 1;
                while (curJ >= 0) {
                    num = num * 10 + mat[curI][curJ--];
                    if (isPrime(num)) {
                        map.put(num, map.getOrDefault(num, 0) + 1);
                    }
                }

                // 向西北移动
                num = mat[i][j];
                curI = i - 1;
                curJ = j - 1;
                while (curI >= 0 && curJ >= 0) {
                    num = num * 10 + mat[curI--][curJ--];
                    if (isPrime(num)) {
                        map.put(num, map.getOrDefault(num, 0) + 1);
                    }
                }

                // 向北移动
                num = mat[i][j];
                curI = i - 1;
                curJ = j;
                while (curI >= 0) {
                    num = num * 10 + mat[curI--][curJ];
                    if (isPrime(num)) {
                        map.put(num, map.getOrDefault(num, 0) + 1);
                    }
                }

                // 向东北移动
                num = mat[i][j];
                curI = i - 1;
                curJ = j + 1;
                while (curI >= 0 && curJ < n) {
                    num = num * 10 + mat[curI--][curJ++];
                    if (isPrime(num)) {
                        map.put(num, map.getOrDefault(num, 0) + 1);
                    }
                }
            }
        }

        int max = 0;
        for (Integer value : map.values()) {
            max = Math.max(max, value);
        }

        if (max == 0) {
            return -1;
        }
        
        int ans = 0;
        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {
            if (max == entry.getValue()) {
                ans = Math.max(ans, entry.getKey());
            }
        }

        return ans;
    }

    private static boolean isPrime(int n) {
        if (n <= 3) {
            return n > 1;
        }
        if (n % 6 != 1 && n % 6 != 5) {
            return false;
        }
        int sqrt = (int) Math.sqrt(n);
        for (int i = 5; i <= sqrt; i += 6) {
            if (n % i == 0 || n % (i + 2) == 0) {
                return false;
            }
        }
        return true;
    }
}
```

**复杂度分析**

- 时间复杂度：$O()$。
- 空间复杂度：$O()$。


--------------------

## [统计前后缀下标对 II](https://leetcode.cn/problems/count-prefix-and-suffix-pairs-ii/)
**思路**

构造正反向字典树。

> 没做出来。

**代码**

```java
class Solution {
    public long countPrefixSuffixPairs(String[] words) {
        long ans = 0;
        PrefixTrie prefixTrie = new PrefixTrie();
        SuffixTrie suffixTrie = new SuffixTrie();
        for (String word : words) {
            Set<String> set = prefixTrie.search(word);
            ans += suffixTrie.search(word, set);
            prefixTrie.insert(word);
            suffixTrie.insert(word);
        }
        return ans;
    }
}

class PrefixTrie {
    public PrefixTrie[] children = new PrefixTrie[26];
    public boolean end = false;
    public String s = null;
    public int count = 0;

    public void insert(String s) {
        int n = s.length();
        PrefixTrie trie = this;
        for (int i = 0; i < n; i++) {
            char c = s.charAt(i);
            if (trie.children[c - 'a'] == null) {
                trie.children[c - 'a'] = new PrefixTrie();
            }
            trie = trie.children[c - 'a'];
        }
        trie.end = true;
        trie.s = s;
        trie.count++;
    }

    public Set<String> search(String s) {
        Set<String> res = new HashSet<>();
        int n = s.length();
        PrefixTrie trie = this;
        for (int i = 0; i < n; i++) {
            char c = s.charAt(i);
            if (trie.children[c - 'a'] == null) {
                break;
            }
            trie = trie.children[c - 'a'];
            if (trie.end) res.add(trie.s);
        }
        return res;
    }
}

class SuffixTrie {
    public SuffixTrie[] children = new SuffixTrie[26];
    public boolean end = false;
    public String s = null;
    public int count = 0;

    public void insert(String s) {
        int n = s.length();
        SuffixTrie trie = this;
        for (int i = n - 1; i >= 0; i--) {
            char c = s.charAt(i);
            if (trie.children[c - 'a'] == null) {
                trie.children[c - 'a'] = new SuffixTrie();
            }
            trie = trie.children[c - 'a'];
        }
        trie.end = true;
        trie.s = s;
        trie.count++;
    }

    public int search(String s, Set<String> set) {
        int res = 0;
        int n = s.length();
        SuffixTrie trie = this;
        for (int i = n - 1; i >= 0; i--) {
            char c = s.charAt(i);
            if (trie.children[c - 'a'] == null) {
                break;
            }
            trie = trie.children[c - 'a'];
            if (trie.end && set.contains(trie.s)) res += trie.count;
        }
        return res;
    }

}
```

**复杂度分析**

- 时间复杂度：$O()$。
- 空间复杂度：$O()$。

