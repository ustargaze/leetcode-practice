# 第 123 场双周赛 (2024-02-03)

> https://leetcode.cn/contest/biweekly-contest-123/

## [三角形类型 II](https://leetcode.cn/problems/type-of-triangle-ii/)
**思路**

按照是不是三角形，是不是等边三角形，是不是等腰三角形三个条件直接写就行了。

**代码**

```java
class Solution {
    public String triangleType(int[] nums) {
        int a = nums[0];
        int b = nums[1];
        int c = nums[2];
        if (a + b <= c || b + c <= a || a + c <= b ) return "none";
        if (a == b && a == c) return "equilateral";
        if (a == b || a == c || b == c) return "isosceles";
        return "scalene";
    }
}
```

**复杂度分析**

- 时间复杂度：$O(1)$。
- 空间复杂度：$O(1)$。


--------------------

## [人员站位的方案数 I](https://leetcode.cn/problems/find-the-number-of-ways-to-place-people-i/)

## [人员站位的方案数 II](https://leetcode.cn/problems/find-the-number-of-ways-to-place-people-ii/)

**思路**

直接枚举点对判断是否符合条件。但是判断点是否在边界或者边界内过于复杂，可以通过排序来简化。将所有点先按照 x 从小到大排序，如果 x 相等再按照 y 从大到小排序。按照 x 排序可以确保取点对的时候，第一个点在第二个点的左边。剩下的就是判断第二个点应在第一个点的下方且边界即边界内没有其他点，这个可以通过判断 y 的范围来确定。符合条件的第二个点的 y 一定要小于第一个点，且要大于前面符合条件的最大的 y 值，才不会包含前面已经符合条件的点。

**代码**

```java
class Solution {
    public int numberOfPairs(int[][] points) {
        int n = points.length;
        Arrays.sort(points, (a, b) -> {
            if (a[0] == b[0]) {
                return b[1] - a[1];
            }
            return a[0] - b[0];
        });


        int ans = 0;
        for (int i = 0; i < n - 1; i++) {
            int max = points[i][1];
            int min = Integer.MIN_VALUE;
            for (int j = i + 1; j < n; j++) {
                int y = points[j][1];
                if (y <= max && y > min) {
                    min = y;
                    ans++;
                }
            }
        }
        
        return ans;
    }
}
```

**复杂度分析**

- 时间复杂度：$O(n^2)$。
- 空间复杂度：$O(1)$。忽略排序的空间复杂度。


--------------------

## [最大好子数组和](https://leetcode.cn/problems/maximum-good-subarray-sum/)
**思路**

一开始的思路是，先计算出数组的前缀和，然后遍历数组将当前值和索引存储到 map 中，可以快速找到已经遍历过的与当前值匹配的值的位置，计算每一个符合条件的区间和取最大值，时间复杂度是$O(n^2)$，最后一个用例超时，没想到怎么优化。

看了别人的题解，同一个值只需要保留前缀和最小的即可。

> 参考：https://leetcode.cn/circle/discuss/nZJeLH/view/obSMb4/

**代码**

```java
class Solution {
    public long maximumSubarraySum(int[] nums, int k) {
        long ans = Long.MIN_VALUE;
        long sum = 0;
        Map<Integer, Long> map = new HashMap<>();
        for (int num : nums) {
            sum += num;
            if (map.containsKey(num - k)) {
                ans = Math.max(ans, sum - map.get(num - k));
            }
            if (map.containsKey(num + k)) {
                ans = Math.max(ans, sum - map.get(num + k));
            }
            if (map.containsKey(num)) {
                map.put(num, Math.min(sum - num, map.get(num)));
            } else {
                map.put(num, sum - num);
            }
        }
        return ans == Long.MIN_VALUE ? 0 : ans;
    }
}
```

**复杂度分析**

- 时间复杂度：$O(n)$。
- 空间复杂度：$O(n)$。
