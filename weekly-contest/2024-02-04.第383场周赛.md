# 第 383 场周赛 (2024-02-04)

> https://leetcode.cn/contest/weekly-contest-383/

## [边界上的蚂蚁](https://leetcode.cn/problems/ant-on-the-boundary/)
**思路**

前缀和等于 0 的个数，就是结果。


**代码**

```java
class Solution {
    public int returnToBoundaryCount(int[] nums) {
        int ans = 0;
        int cur = 0;
        for (int n : nums) {
            cur += n;
            if (cur == 0) {
                ans++;
            }
        }
        return ans;
    }
}
```

**复杂度分析**

- 时间复杂度：$O(n)$。
- 空间复杂度：$O(1)$。


--------------------

## [将单词恢复初始状态所需的最短时间 I](https://leetcode.cn/problems/minimum-time-to-revert-word-to-initial-state-i/)

## [将单词恢复初始状态所需的最短时间 II](https://leetcode.cn/problems/minimum-time-to-revert-word-to-initial-state-ii/)

**思路**

只需要判断第 i 次操作的时候，word.subString(0, n - i\*k) 和 word.subString(i\*k, n) 是否相等即可。而 i 的最大值为 $\left \lceil \frac{n}{k}  \right \rceil $​

> 一开始直接用 subString 取子字符串然后判断相等，第二道题会超时，然后改成了下面的代码过了。（python直接切片和 js 用 subString 也能过）。🤣
>
> java 用 word.startsWith(word.subString(i*k)) 也能过 🥲

**代码**

```java
class Solution {
    public int minimumTimeToInitialState(String word, int k) {
        int n = word.length();
        char[] chars = word.toCharArray();
        int i = 1;
        for (; i * k < n; i++) {
            int p = n - i * k - 1, q = n - 1;
            boolean flag = true;
            for (; p >= 0; p--, q--) {
                if (chars[p] != chars[q]) {
                    flag = false;
                    break;
                }
            }

            if (flag) {
                return i;
            }
        }
        return i;
    }
}
```

**复杂度分析**

- 时间复杂度：$O(\frac{n^2}{k})$。
- 空间复杂度：$O(1)$​。忽略字符串转成字符数组需要的空间



用字符串哈希或者扩展 KMP 能够进一步优化成线性时间复杂度

字符串哈希参考：https://leetcode.cn/circle/discuss/WmtlPM/view/6PXrLs/

扩展 KMP 参考：https://leetcode.cn/problems/minimum-time-to-revert-word-to-initial-state-ii/solutions/2630932/z-han-shu-kuo-zhan-kmp-by-endlesscheng-w44j




--------------------

## [找出网格的区域平均强度](https://leetcode.cn/problems/find-the-grid-of-region-average/)
**思路**

> 这题我想吐🥶

按照题目的意思模拟


**代码**

```java
class Solution {
    public int[][] resultGrid(int[][] image, int threshold) {
        int m = image.length, n = image[0].length;
        int[][] result = new int[m][n];
        int[][] base = new int[m][n];

        for (int i = 0; i < m - 2; i++) {
            for (int j = 0; j < n - 2; j++) {
                if (isArea(i, j, image, threshold)) {
                    fillResult(i, j, image, result, base);
                }
            }
        }

        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (base[i][j] == 0) {
                    result[i][j] = image[i][j];
                } else {
                    result[i][j] = result[i][j] / base[i][j];
                }
            }
        }

        return result;
    }

    private void fillResult(int i, int j, int[][] image, int[][] result, int[][] base) {
        int sum = 0;
        for (int k = i; k < i + 3; k++) {
            for (int l = j; l < j + 3; l++) {
                sum += image[k][l];
            }
        }

        int avg = sum / 9;
        for (int k = i; k < i + 3; k++) {
            for (int l = j; l < j + 3; l++) {
                result[k][l] += avg;
                base[k][l]++;
            }
        }
    }

    private boolean isArea(int i, int j, int[][] image, int threshold) {
        for (int k = i; k < i + 3; k++) {
            for (int l = j; l < j + 2; l++) {
                if (Math.abs(image[k][l] - image[k][l + 1]) > threshold) {
                    return false;
                }
            }
        }
        for (int k = i; k < i + 2; k++) {
            for (int l = j; l < j + 3; l++) {
                if (Math.abs(image[k][l] - image[k + 1][l]) > threshold) {
                    return false;
                }
            }
        }

        return true;
    }
}
```

**复杂度分析**

- 时间复杂度：$O(mn)$。
- 空间复杂度：$O(mn)$。

