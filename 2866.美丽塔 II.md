# 2866.美丽塔 II

> [2866. 美丽塔 II](https://leetcode.cn/problems/beautiful-towers-ii/)
>
> 难度：<font color=orange>`Medium`</font>
>
> 标签：`栈` `数组` `单调栈`

## 题目

给你一个长度为 `n` 下标从 **0** 开始的整数数组 `maxHeights` 。

你的任务是在坐标轴上建 `n` 座塔。第 `i` 座塔的下标为 `i` ，高度为 `heights[i]` 。

如果以下条件满足，我们称这些塔是 **美丽** 的：

1. `1 <= heights[i] <= maxHeights[i]`
2. `heights` 是一个 **山脉** 数组。

如果存在下标 `i` 满足以下条件，那么我们称数组 `heights` 是一个 **山脉** 数组：

* 对于所有 `0 < j <= i` ，都有 `heights[j - 1] <= heights[j]`
* 对于所有 `i <= k < n - 1` ，都有 `heights[k + 1] <= heights[k]`

请你返回满足 **美丽塔** 要求的方案中，**高度和的最大值** 。

**示例 1：**

```
输入：maxHeights = [5,3,4,1,1]
输出：13
解释：和最大的美丽塔方案为 heights = [5,3,3,1,1] ，这是一个美丽塔方案，因为：
- 1 <= heights[i] <= maxHeights[i]  
- heights 是个山脉数组，峰值在 i = 0 处。
13 是所有美丽塔方案中的最大高度和。
```

**示例 2：**

```
输入：maxHeights = [6,5,3,9,2,7]
输出：22
解释： 和最大的美丽塔方案为 heights = [3,3,3,9,2,2] ，这是一个美丽塔方案，因为：
- 1 <= heights[i] <= maxHeights[i]
- heights 是个山脉数组，峰值在 i = 3 处。
22 是所有美丽塔方案中的最大高度和。
```

**示例 3：**

```
输入：maxHeights = [3,2,5,5,2,3]
输出：18
解释：和最大的美丽塔方案为 heights = [2,2,5,5,2,2] ，这是一个美丽塔方案，因为：
- 1 <= heights[i] <= maxHeights[i]
- heights 是个山脉数组，最大值在 i = 2 处。
注意，在这个方案中，i = 3 也是一个峰值。
18 是所有美丽塔方案中的最大高度和。
```

**提示：**

* `1 <= n == maxHeights <= 10^5`
* `1 <= maxHeights[i] <= 10^9`

--------------------

## 题解

### 方法一：暴力破解（超时）

**思路**

heights 数组为山脉数组，即满足先非递减后非递增即可。依次以 maxHeights 中的每一个元素为峰值，根据山脉数组的特点和 maxHeights 的限制，即：

- 对于 j∈[0,i−1] 时，此时 max(heights[j])=min(heights[j+1],maxHeights[j])；
- 对于 j∈[i+1,n−1] 时，此 时 max(heights[j])=min(heights[j−1],maxHeights[j])；

找出左右两边的高度即可。

**代码**

```java
class Solution {
    public long maximumSumOfHeights(List<Integer> maxHeights) {
        long ans = 0;
        int n = maxHeights.size();
        int[] heights = new int[n];
        for (int i = 0; i < n; i++) {
            heights[i] = maxHeights.get(i);
            int left = i - 1, right = i + 1;

            while(left >= 0) {
                heights[left] = Math.min(heights[left + 1], maxHeights.get(left));
                left--;
            }
            while(right < n) {
                heights[right] = Math.min(heights[right - 1], maxHeights.get(right));
                right++;
            }

            long sum = 0;
            for (int height : heights) {
                sum += height;
            }

            ans = Math.max(ans, sum);
        }

        return ans;
    }
}
```

**复杂度分析**

- 时间复杂度：$O(n^2)$。
- 空间复杂度：$O(n)$。

### 方法二：单调栈（不会）

**思路**

> <font color=red>**不会做，没有思路。**</font>

请看题解：https://leetcode.cn/problems/beautiful-towers-ii/solutions/2563770/mei-li-ta-ii-by-leetcode-solution-2j4s/

对于每个索引 `i`，可以将数组分为两部分处理，即保证数组的左侧构成非递减，右侧构成非递增。为了使得数组元素尽可能大，此时 `heights[i]` 应取值为 `maxHeights[i]`，设区间 `[0,i]` 构成的非递减数组元素和最大值为 `prefix[i]`，区间 `[i,n−1]` 构成的非递增数组元素和最大值为 `suffix[i]`，此时构成的山状数组的元素之和即为 `prefix[i]+suffix[i]−maxHeights[i]`。

如何使得数组成为递增或递减，此时我们想到「单调栈」，「单调栈」可以保证栈中数据的单调性，利用单调栈将连续子数组变为非递减或非递减。

- 对于左侧的非递减：将 `maxHeights` 依次入栈，对于第 `i` 个元素来说，不断从栈顶弹出元素，直到栈顶元素小于等于 `maxHeights[i]`。假设此时栈顶元素为 `maxHeights[j]`，则区间 `[j+1,i−1]` 中的元素最多只能取到 `maxHeights[i]`，则 p`refix[i]=prefix[j]+(i−j)×maxHeights[i]`；
- 对于右侧的非递减：将 `maxHeights` 依次入栈，对于第 `i` 个元素来说，不断从栈顶弹出元素，直到栈顶元素小于等于 `maxHeights[i]`。假设此时栈顶元素为 `maxHeights[j]`，则区间 `[i+1,j−1]` 中的元素最多只能取到 `maxHeights[i]`，则 `suffix[i]=suffix[j]+(j−i)×maxHeights[i]`；

我们按照上述规则枚举每个位置 `i`，并计算出以 `i` 为山顶的数组之和，此时山状数组的最大值即为 `max⁡(prefix[i]+suffix[i]−maxHeights[i])`。

**代码**

```java
class Solution {
    public long maximumSumOfHeights(List<Integer> maxHeights) {
        int n = maxHeights.size();
        long res = 0;
        long[] prefix = new long[n];
        long[] suffix = new long[n];
        Deque<Integer> stack1 = new ArrayDeque<Integer>();
        Deque<Integer> stack2 = new ArrayDeque<Integer>();

        for (int i = 0; i < n; i++) {
            while (!stack1.isEmpty() && maxHeights.get(i) < maxHeights.get(stack1.peek())) {
                stack1.pop();
            }
            if (stack1.isEmpty()) {
                prefix[i] = (long) (i + 1) * maxHeights.get(i);
            } else {
                prefix[i] = prefix[stack1.peek()] + (long) (i - stack1.peek()) * maxHeights.get(i);
            }
            stack1.push(i);
        }
        for (int i = n - 1; i >= 0; i--) {
            while (!stack2.isEmpty() && maxHeights.get(i) < maxHeights.get(stack2.peek())) {
                stack2.pop();
            }
            if (stack2.isEmpty()) {
                suffix[i] = (long) (n - i) * maxHeights.get(i);
            } else {
                suffix[i] = suffix[stack2.peek()] + (long) (stack2.peek() - i) * maxHeights.get(i);
            }
            stack2.push(i);
            res = Math.max(res, prefix[i] + suffix[i] - maxHeights.get(i));
        }
        return res;
    }
}
```

**复杂度分析**

- 时间复杂度：$O(n)$。
- 空间复杂度：$O(n)$。

### 拓展

1. 什么是单调栈？

   https://oi-wiki.org/ds/monotonous-stack/

   单调栈即满足单调性的栈结构。
