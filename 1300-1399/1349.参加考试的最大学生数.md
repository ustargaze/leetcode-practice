# 1349. 参加考试的最大学生数

> [1349. 参加考试的最大学生数](https://leetcode.cn/problems/maximum-students-taking-exam/)
>
> 难度：<font color=red>`Hard`</font>
>
> 标签：`位运算` `数组` `动态规划` `状态压缩` `矩阵`

## 题目

给你一个 `m * n` 的矩阵 `seats` 表示教室中的座位分布。如果座位是坏的（不可用），就用 `'#'` 表示；否则，用 `'.'` 表示。

学生可以看到左侧、右侧、左上、右上这四个方向上紧邻他的学生的答卷，但是看不到直接坐在他前面或者后面的学生的答卷。请你计算并返回该考场可以容纳的同时参加考试且无法作弊的 **最大** 学生人数。

学生必须坐在状况良好的座位上。

**示例 1：**

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/09/image.png)

```
输入：seats = [["#",".","#","#",".","#"],
              [".","#","#","#","#","."],
              ["#",".","#","#",".","#"]]
输出：4
解释：教师可以让 4 个学生坐在可用的座位上，这样他们就无法在考试中作弊。 
```

**示例 2：**

```
输入：seats = [[".","#"],
              ["#","#"],
              ["#","."],
              ["#","#"],
              [".","#"]]
输出：3
解释：让所有学生坐在可用的座位上。
```

**示例 3：**

```
输入：seats = [["#",".",".",".","#"],
              [".","#",".","#","."],
              [".",".","#",".","."],
              [".","#",".","#","."],
              ["#",".",".",".","#"]]
输出：10
解释：让学生坐在第 1、3 和 5 列的可用座位上。
```

**提示：**

* `seats` 只包含字符 `'.' 和``'#'`
* `m == seats.length`
* `n == seats[i].length`
* `1 <= m <= 8`
* `1 <= n <= 8`

--------------------

## 题解

> 参考：[https://leetcode.cn/problems/maximum-students-taking-exam/solutions/2580043/jiao-ni-yi-bu-bu-si-kao-dong-tai-gui-hua-9y5k/](https://leetcode.cn/problems/maximum-students-taking-exam/solutions/2580043/jiao-ni-yi-bu-bu-si-kao-dong-tai-gui-hua-9y5k/)

### 方法一：记忆搜索

**代码**

```java
class Solution {
    public int maxStudents(char[][] seats) {
        int m = seats.length;
        int n = seats[0].length;
        int[] mask = new int[m];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (seats[i][j] == '.') {
                    mask[i] |= 1 << j;
                }
            }
        }

        int[][] memo = new int[m][1 << n];
        for (int[] row : memo) {
            Arrays.fill(row, -1);
        }

        return dfs(m - 1, mask[m - 1], mask, memo);
    }

    private int dfs(int i, int j, int[] mask, int[][] memo) {
        if (memo[i][j] != -1) {
            return memo[i][j];
        }
        
        if (i == 0) {
            if (j == 0) {
                return 0;
            }
            int lb = j & -j;
            return memo[i][j] = dfs(i, j & ~(lb * 3), mask, memo) + 1;
        }
        int res = dfs(i - 1, mask[i - 1], mask, memo);
        for (int s = j; s > 0; s = (s - 1) & j) {
            if ((s & (s >> 1)) == 0) {
                int t = mask[i - 1] & ~(s << 1 | s >> 1);
                res = Math.max(res, dfs(i - 1, t, mask, memo) + Integer.bitCount(s));
            }
        }
        return memo[i][j] = res;
    }
}
```

**复杂度分析**

- 时间复杂度：$O(m \times 3^n)$。
- 空间复杂度：$O(m \times 2^n)$。
