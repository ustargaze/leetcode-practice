# 5. 最长回文子串

> [5. 最长回文子串](https://leetcode.cn/problems/longest-palindromic-substring/)
>
> 难度：<font color=orange>`Medium`</font>
>
> 标签：`字符串` `动态规划`

## 题目

<p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。</p>

<p>如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>s = "babad"
<strong>输出：</strong>"bab"
<strong>解释：</strong>"aba" 同样是符合题意的答案。
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>s = "cbbd"
<strong>输出：</strong>"bb"
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 1000</code></li>
	<li><code>s</code> 仅由数字和英文字母组成</li>
</ul>


--------------------

## 题解

### 方法一：枚举

> 暂时只能想到这个了

**思路**

双重循环遍历枚举字符串所有的子串找到最大的回文子串。但是第二层循环优先从长度最大的开始枚举，即 j 从 n - 1 开始递减，记录找到的第一个回文子串的长度和起始位置。如果 i 到 j 之间的字符串长度已经不大于 已经找到的最大回文子串的长度即可结束循环。

**代码**

```java
class Solution {
    public String longestPalindrome(String s) {
        char[] chars = s.toCharArray();
        int n = chars.length;
        int maxPalindromeLength = 0, start = 0;
        for (int i = 0; i < n; i++) {
            if (n - i < maxPalindromeLength) {
                break;
            }
            for (int j = n - 1; j >= i ; j--) {
                if (j - i + 1 < maxPalindromeLength) {
                    break;
                }
                if (isPalindrome(chars, i, j)) {
                    maxPalindromeLength = j - i + 1;
                    start = i;
                    break;
                }
            }
        }
        return s.substring(start, start + maxPalindromeLength);
    }

    private boolean isPalindrome(char[] s, int left, int right) {
        while(left < right) {
            if (s[left++] != s[right--]) {
                return false;
            }
        }
        return true;
    }
}
```

**复杂度分析**

- 时间复杂度：$O(n^2)$。
- 空间复杂度：$O(n)$。将字符串转成了char数组，对数组的遍历会比遍历字符串快。
